// 01_æ ‡å‡†åº“æ¦‚è¿°.rs
// Rustæ ‡å‡†åº“(std)å®Œæ•´æ¦‚è¿°ä¸å­¦ä¹ æŒ‡å—

/*
=== Rustæ ‡å‡†åº“(std)å®Œæ•´æ•™ç¨‹ç³»åˆ— ===

æœ¬æ•™ç¨‹ç³»åˆ—æä¾›äº†Rustæ ‡å‡†åº“çš„å…¨é¢å­¦ä¹ èµ„æºï¼Œæ¶µç›–12ä¸ªæ ¸å¿ƒæ¨¡å—ï¼š

ğŸ“š æ•™ç¨‹ç»“æ„ï¼š
01_æ ‡å‡†åº“æ¦‚è¿°.rs     - æ ‡å‡†åº“æ•´ä½“æ¦‚å†µå’ŒåŸºç¡€æ¦‚å¿µ (æœ¬æ–‡ä»¶)
02_é›†åˆç±»å‹.rs       - Vecã€HashMapã€HashSetç­‰é›†åˆæ•°æ®ç»“æ„
03_å­—ç¬¦ä¸²å¤„ç†.rs     - Stringã€&strå’Œå­—ç¬¦ä¸²æ“ä½œæ–¹æ³•
04_é”™è¯¯å¤„ç†.rs       - Resultã€Optionå’Œé”™è¯¯å¤„ç†æ¨¡å¼
05_è¾“å…¥è¾“å‡º.rs       - æ–‡ä»¶I/Oã€æ ‡å‡†è¾“å…¥è¾“å‡ºæ“ä½œ
06_ç½‘ç»œç¼–ç¨‹.rs       - TCP/UDPç½‘ç»œç¼–ç¨‹å’ŒSocketæ“ä½œ
07_çº¿ç¨‹å¹¶å‘.rs       - å¤šçº¿ç¨‹ç¼–ç¨‹å’Œå¹¶å‘æ§åˆ¶
08_æ—¶é—´æ—¥æœŸ.rs       - æ—¶é—´å¤„ç†ã€Durationå’Œæ€§èƒ½æµ‹é‡
09_å†…å­˜ç®¡ç†.rs       - æ‰€æœ‰æƒç³»ç»Ÿã€æ™ºèƒ½æŒ‡é’ˆå’Œå†…å­˜ä¼˜åŒ–
10_æ–‡ä»¶ç³»ç»Ÿæ“ä½œ.rs   - æ–‡ä»¶ç³»ç»ŸAPIã€è·¯å¾„å¤„ç†å’Œå…ƒæ•°æ®
11_è¿›ç¨‹ä¸ç¯å¢ƒ.rs     - è¿›ç¨‹ç®¡ç†ã€ç¯å¢ƒå˜é‡å’Œç³»ç»Ÿä¿¡æ¯
12_æ•°æ®åºåˆ—åŒ–.rs     - æ•°æ®æ ¼å¼åŒ–ã€åºåˆ—åŒ–å’Œååºåˆ—åŒ–

ğŸ¯ stdåº“çš„æ ¸å¿ƒæ¨¡å—åˆ†ç±»ï¼š

1. ğŸ“Š æ•°æ®ç»“æ„æ¨¡å—ï¼š
   - std::collections - é›†åˆç±»å‹ (Vec, HashMap, BTreeMapç­‰)
   - std::string - å­—ç¬¦ä¸²ç±»å‹ (String)
   - std::vec - åŠ¨æ€æ•°ç»„
   
2. ğŸ”§ å†…å­˜ç®¡ç†æ¨¡å—ï¼š
   - std::boxed - å †åˆ†é… (Box<T>)
   - std::rc - å¼•ç”¨è®¡æ•° (Rc<T>, Weak<T>)
   - std::sync - åŒæ­¥åŸè¯­ (Arc<T>, Mutex<T>)
   - std::cell - å†…éƒ¨å¯å˜æ€§ (RefCell<T>, Cell<T>)
   - std::mem - å†…å­˜æ“ä½œå·¥å…·
   
3. ğŸ”€ é”™è¯¯å¤„ç†æ¨¡å—ï¼š
   - std::result - Result<T, E> ç±»å‹
   - std::option - Option<T> ç±»å‹
   - std::error - é”™è¯¯traitå®šä¹‰
   - std::panic - panicå¤„ç†æœºåˆ¶
   
4. ğŸ’¾ I/Oæ“ä½œæ¨¡å—ï¼š
   - std::io - è¾“å…¥è¾“å‡ºtraitå’Œå·¥å…·
   - std::fs - æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
   - std::net - ç½‘ç»œç¼–ç¨‹API
   - std::path - è·¯å¾„å¤„ç†
   
5. âš¡ å¹¶å‘ç¼–ç¨‹æ¨¡å—ï¼š
   - std::thread - çº¿ç¨‹ç®¡ç†
   - std::sync::mpsc - æ¶ˆæ¯ä¼ é€’é€šé“
   - std::sync - åŒæ­¥åŸè¯­ (Mutex, RwLock, Barrierç­‰)
   - std::sync::atomic - åŸå­ç±»å‹
   
6. â° æ—¶é—´å¤„ç†æ¨¡å—ï¼š
   - std::time - æ—¶é—´å’ŒæŒç»­æ—¶é—´
   - std::thread::sleep - çº¿ç¨‹ä¼‘çœ 
   
7. ğŸ”„ æ ¼å¼åŒ–å’Œè½¬æ¢ï¼š
   - std::fmt - æ ¼å¼åŒ–trait
   - std::str - å­—ç¬¦ä¸²åˆ‡ç‰‡å·¥å…·
   - std::convert - ç±»å‹è½¬æ¢trait
   
8. ğŸ–¥ï¸ ç³»ç»Ÿäº¤äº’æ¨¡å—ï¼š
   - std::env - ç¯å¢ƒå˜é‡å’Œç¨‹åºå‚æ•°
   - std::process - è¿›ç¨‹ç®¡ç†
   - std::ffi - å¤–éƒ¨å‡½æ•°æ¥å£
   
9. ğŸ§® æ•°å­¦å’Œå·¥å…·ï¼š
   - std::cmp - æ¯”è¾ƒtrait
   - std::ops - è¿ç®—ç¬¦é‡è½½
   - std::iter - è¿­ä»£å™¨traitå’Œå·¥å…·
   - std::marker - æ ‡è®°trait

ğŸ“‹ stdåº“çš„é‡è¦ç‰¹ç‚¹ï¼š

ğŸ›¡ï¸ å®‰å…¨æ€§ä¿è¯ï¼š
- å†…å­˜å®‰å…¨ï¼šé˜²æ­¢ç¼“å†²åŒºæº¢å‡ºã€æ‚¬æŒ‚æŒ‡é’ˆ
- çº¿ç¨‹å®‰å…¨ï¼šæ•°æ®ç«äº‰ç¼–è¯‘æ—¶æ£€æŸ¥
- ç±»å‹å®‰å…¨ï¼šå¼ºç±»å‹ç³»ç»Ÿé˜²æ­¢é”™è¯¯

âš¡ æ€§èƒ½ç‰¹ç‚¹ï¼š
- é›¶æˆæœ¬æŠ½è±¡ï¼šé«˜çº§ç‰¹æ€§æ— è¿è¡Œæ—¶å¼€é”€  
- ç¼–è¯‘æ—¶ä¼˜åŒ–ï¼šå¤§éƒ¨åˆ†æ£€æŸ¥åœ¨ç¼–è¯‘æœŸå®Œæˆ
- é«˜æ•ˆå†…å­˜ç®¡ç†ï¼šRAIIå’Œç¡®å®šæ€§ææ„

ğŸŒ è·¨å¹³å°æ”¯æŒï¼š
- ç»Ÿä¸€APIï¼šä¸åŒæ“ä½œç³»ç»Ÿæä¾›ä¸€è‡´æ¥å£
- æ¡ä»¶ç¼–è¯‘ï¼šå¹³å°ç‰¹å®šåŠŸèƒ½çš„ä¼˜é›…å¤„ç†
- æ ‡å‡†åŒ–ï¼šéµå¾ªç°ä»£ç³»ç»Ÿç¼–ç¨‹æ ‡å‡†

ğŸ”§ ä½¿ç”¨æŒ‡å—ï¼š

å…¥é—¨å­¦ä¹ è·¯å¾„ï¼š
1. åŸºç¡€ (01-05)ï¼šæ¦‚è¿° â†’ é›†åˆ â†’ å­—ç¬¦ä¸² â†’ é”™è¯¯å¤„ç† â†’ I/O
2. ç½‘ç»œå¹¶å‘ (06-07)ï¼šç½‘ç»œç¼–ç¨‹ â†’ çº¿ç¨‹å¹¶å‘  
3. ç³»ç»Ÿçº§ (08-12)ï¼šæ—¶é—´ â†’ å†…å­˜ â†’ æ–‡ä»¶ç³»ç»Ÿ â†’ è¿›ç¨‹ â†’ åºåˆ—åŒ–

å®è·µå»ºè®®ï¼š
- æ¯ä¸ªæ•™ç¨‹éƒ½åŒ…å«å®Œæ•´çš„ä»£ç ç¤ºä¾‹
- è¿è¡Œæµ‹è¯•ç”¨ä¾‹éªŒè¯ç†è§£
- ç»“åˆå®é™…é¡¹ç›®åŠ æ·±å­¦ä¹ 
- å‚è€ƒæ ‡å‡†åº“æ–‡æ¡£æ·±å…¥äº†è§£

ğŸ”— ç›¸å…³èµ„æºï¼š
- å®˜æ–¹æ–‡æ¡£ï¼šhttps://doc.rust-lang.org/std/
- Rustç¨‹åºè®¾è®¡è¯­è¨€ï¼šhttps://kaisery.github.io/trpl-zh-cn/
- Rustå‚è€ƒæ‰‹å†Œï¼šhttps://doc.rust-lang.org/reference/
*/

use std::fmt;
use std::collections::HashMap;
use std::fs;
use std::io;
use std::thread;
use std::time::Duration;

fn main() {
    println!("=== Rustæ ‡å‡†åº“æ¦‚è¿° ===");
    
    // 1. åŸºæœ¬æ•°æ®ç»“æ„ç¤ºä¾‹
    println!("\n1. åŸºæœ¬æ•°æ®ç»“æ„ï¼š");
    
    // Vec - åŠ¨æ€æ•°ç»„
    let mut numbers: Vec<i32> = vec![1, 2, 3, 4, 5];
    numbers.push(6);
    println!("Vecç¤ºä¾‹: {:?}", numbers);
    
    // HashMap - å“ˆå¸Œè¡¨
    let mut map: HashMap<String, i32> = HashMap::new();
    map.insert("è‹¹æœ".to_string(), 10);
    map.insert("é¦™è•‰".to_string(), 20);
    println!("HashMapç¤ºä¾‹: {:?}", map);
    
    // 2. å­—ç¬¦ä¸²å¤„ç†
    println!("\n2. å­—ç¬¦ä¸²å¤„ç†ï¼š");
    let greeting = "ä½ å¥½ï¼Œä¸–ç•Œï¼";
    let owned_string = String::from("Rustç¼–ç¨‹");
    println!("å­—ç¬¦ä¸²åˆ‡ç‰‡: {}", greeting);
    println!("æ‹¥æœ‰çš„å­—ç¬¦ä¸²: {}", owned_string);
    
    // 3. é”™è¯¯å¤„ç†
    println!("\n3. é”™è¯¯å¤„ç†ï¼š");
    match divide(10, 2) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
    
    match divide(10, 0) {
        Ok(result) => println!("10 / 0 = {}", result),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
    
    // 4. Optionç±»å‹
    println!("\n4. Optionç±»å‹ï¼š");
    let some_value = Some(42);
    let none_value: Option<i32> = None;
    
    match some_value {
        Some(value) => println!("æ‰¾åˆ°å€¼: {}", value),
        None => println!("æ²¡æœ‰å€¼"),
    }
    
    match none_value {
        Some(value) => println!("æ‰¾åˆ°å€¼: {}", value),
        None => println!("æ²¡æœ‰å€¼"),
    }
    
    // 5. è¿­ä»£å™¨ç¤ºä¾‹
    println!("\n5. è¿­ä»£å™¨ï¼š");
    let data = vec![1, 2, 3, 4, 5];
    let doubled: Vec<i32> = data.iter().map(|x| x * 2).collect();
    println!("åŸå§‹æ•°æ®: {:?}", data);
    println!("ç¿»å€å: {:?}", doubled);
    
    // 6. æ—¶é—´å¤„ç†
    println!("\n6. æ—¶é—´å¤„ç†ï¼š");
    let now = std::time::SystemTime::now();
    println!("å½“å‰æ—¶é—´: {:?}", now);
    
    // 7. çº¿ç¨‹ç®€å•ç¤ºä¾‹
    println!("\n7. çº¿ç¨‹ç¤ºä¾‹ï¼š");
    let handle = thread::spawn(|| {
        println!("åœ¨å­çº¿ç¨‹ä¸­è¿è¡Œ");
        thread::sleep(Duration::from_millis(100));
        "å­çº¿ç¨‹å®Œæˆ"
    });
    
    match handle.join() {
        Ok(result) => println!("å­çº¿ç¨‹ç»“æœ: {}", result),
        Err(_) => println!("å­çº¿ç¨‹æ‰§è¡Œå¤±è´¥"),
    }
    
    // 8. æ¨¡å—å¯¼è§ˆ
    println!("\n8. åç»­å­¦ä¹ æ¨¡å—ï¼š");
    module_overview();
    
    println!("\n=== æ ‡å‡†åº“æ¦‚è¿°å®Œæˆ ===");
    println!("ğŸ“ æ­å–œå®ŒæˆRustæ ‡å‡†åº“æ¦‚è¿°å­¦ä¹ ï¼");
    println!("ğŸ“– å»ºè®®ç»§ç»­å­¦ä¹ ï¼š02_é›†åˆç±»å‹.rs");
}
}

// æ¨¡å—å¯¼è§ˆå‡½æ•°
fn module_overview() {
    println!("ğŸ“š å®Œæ•´æ•™ç¨‹ç³»åˆ—åŒ…å«12ä¸ªæ ¸å¿ƒæ¨¡å—ï¼š");
    
    let modules = [
        ("02_é›†åˆç±»å‹.rs", "ğŸ“Š", "Vecã€HashMapã€HashSetç­‰æ•°æ®ç»“æ„"),
        ("03_å­—ç¬¦ä¸²å¤„ç†.rs", "ğŸ“", "Stringã€&strå’Œå­—ç¬¦ä¸²æ“ä½œ"),
        ("04_é”™è¯¯å¤„ç†.rs", "âš ï¸", "Resultã€Optionå’Œé”™è¯¯æ¨¡å¼"),
        ("05_è¾“å…¥è¾“å‡º.rs", "ğŸ’¾", "æ–‡ä»¶I/Oã€æ ‡å‡†è¾“å…¥è¾“å‡º"),
        ("06_ç½‘ç»œç¼–ç¨‹.rs", "ğŸŒ", "TCP/UDPç½‘ç»œç¼–ç¨‹"),
        ("07_çº¿ç¨‹å¹¶å‘.rs", "âš¡", "å¤šçº¿ç¨‹å’Œå¹¶å‘æ§åˆ¶"),
        ("08_æ—¶é—´æ—¥æœŸ.rs", "â°", "æ—¶é—´å¤„ç†å’Œæ€§èƒ½æµ‹é‡"),
        ("09_å†…å­˜ç®¡ç†.rs", "ğŸ§ ", "æ‰€æœ‰æƒã€æ™ºèƒ½æŒ‡é’ˆå’Œå†…å­˜ä¼˜åŒ–"),
        ("10_æ–‡ä»¶ç³»ç»Ÿæ“ä½œ.rs", "ğŸ“", "æ–‡ä»¶ç³»ç»ŸAPIå’Œè·¯å¾„å¤„ç†"),
        ("11_è¿›ç¨‹ä¸ç¯å¢ƒ.rs", "ğŸ–¥ï¸", "è¿›ç¨‹ç®¡ç†å’Œç³»ç»Ÿäº¤äº’"),
        ("12_æ•°æ®åºåˆ—åŒ–.rs", "ğŸ”„", "æ•°æ®æ ¼å¼åŒ–å’Œåºåˆ—åŒ–"),
    ];
    
    for (filename, icon, description) in &modules {
        println!("  {} {} - {}", icon, filename, description);
    }
    
    println!("\nğŸ¯ å­¦ä¹ å»ºè®®ï¼š");
    println!("  â€¢ åˆå­¦è€…ï¼šæŒ‰é¡ºåºå­¦ä¹  02â†’05 åŸºç¡€æ¨¡å—");
    println!("  â€¢ è¿›é˜¶è€…ï¼šé‡ç‚¹å­¦ä¹  06â†’07 ç½‘ç»œå¹¶å‘æ¨¡å—");
    println!("  â€¢ ç³»ç»Ÿç¼–ç¨‹ï¼šæ·±å…¥å­¦ä¹  08â†’12 ç³»ç»Ÿçº§æ¨¡å—");
    println!("  â€¢ æ¯ä¸ªæ¨¡å—éƒ½æœ‰å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œæµ‹è¯•");
    println!("  â€¢ å»ºè®®åŠ¨æ‰‹è¿è¡Œä»£ç åŠ æ·±ç†è§£");
}

// é”™è¯¯å¤„ç†ç¤ºä¾‹å‡½æ•°
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("é™¤æ•°ä¸èƒ½ä¸º0".to_string())
    } else {
        Ok(a / b)
    }
}

// è‡ªå®šä¹‰ç»“æ„ä½“å®ç°Display trait
struct Person {
    name: String,
    age: u32,
}

impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "å§“å: {}, å¹´é¾„: {}", self.name, self.age)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_divide_success() {
        assert_eq!(divide(10, 2), Ok(5));
    }
    
    #[test]
    fn test_divide_error() {
        assert_eq!(divide(10, 0), Err("é™¤æ•°ä¸èƒ½ä¸º0".to_string()));
    }
    
    #[test]
    fn test_person_display() {
        let person = Person {
            name: "å¼ ä¸‰".to_string(),
            age: 30,
        };
        assert_eq!(format!("{}", person), "å§“å: å¼ ä¸‰, å¹´é¾„: 30");
    }
}