# H2 0.4.11 - Rust HTTP/2 客户端和服务器库使用教程

## 概述

H2 是一个纯 Rust 实现的 HTTP/2 客户端和服务器库，由 Hyperium 团队开发。它提供了完整的 HTTP/2 协议支持，包括多路复用、服务器推送、流控制等高级特性。

**基本信息：**
- 版本：0.4.11
- 许可证：MIT
- 仓库：https://github.com/hyperium/h2
- 文档：https://docs.rs/h2
- 下载量：301,505,037+

## 安装

在 `Cargo.toml` 中添加：

```toml
[dependencies]
h2 = "0.4"
tokio = { version = "1.0", features = ["full"] }
```

## HTTP/2 基础概念

### 1. 核心特性

- **多路复用（Multiplexing）**：在单个连接上并行发送多个请求
- **服务器推送（Server Push）**：服务器主动推送资源到客户端
- **流控制（Flow Control）**：控制数据传输速率
- **头部压缩（Header Compression）**：使用 HPACK 压缩 HTTP 头部

### 2. 关键组件

```rust
use h2::client::{self, Client};
use h2::server::{self, Server};
use h2::{Request, Response, RecvStream, SendStream};
use tokio::net::TcpStream;

// 基本类型
// - Client: HTTP/2 客户端
// - Server: HTTP/2 服务器
// - Request: HTTP 请求
// - Response: HTTP 响应
// - SendStream: 发送流
// - RecvStream: 接收流
```

## 客户端使用

### 1. 基本客户端

```rust
use h2::client;
use http::{Request, Method};
use tokio::net::TcpStream;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 建立 TCP 连接
    let tcp = TcpStream::connect("httpbin.org:443").await?;
    
    // 建立 HTTP/2 连接
    let (mut client, h2) = client::handshake(tcp).await?;
    
    // 启动连接处理任务
    tokio::spawn(async move {
        if let Err(e) = h2.await {
            println!("HTTP/2 连接错误: {}", e);
        }
    });
    
    // 创建 GET 请求
    let request = Request::builder()
        .method(Method::GET)
        .uri("https://httpbin.org/get")
        .body(())?;
    
    // 发送请求
    let (response, mut send_stream) = client.send_request(request, false)?;
    
    // 关闭请求体（因为这是 GET 请求）
    send_stream.send_data(bytes::Bytes::new(), true)?;
    
    // 接收响应
    let response = response.await?;
    println!("响应状态: {}", response.status());
    println!("响应头: {:?}", response.headers());
    
    // 接收响应体
    let mut body = response.into_body();
    while let Some(chunk) = body.data().await {
        match chunk {
            Ok(bytes) => println!("接收到数据: {}", String::from_utf8_lossy(&bytes)),
            Err(e) => println!("读取错误: {}", e),
        }
    }
    
    Ok(())
}
```

### 2. 并发请求

```rust
use h2::client;
use http::{Request, Method};
use tokio::net::TcpStream;
use futures::future::join_all;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let tcp = TcpStream::connect("httpbin.org:443").await?;
    let (mut client, h2) = client::handshake(tcp).await?;
    
    // 启动连接处理任务
    tokio::spawn(async move {
        if let Err(e) = h2.await {
            println!("HTTP/2 连接错误: {}", e);
        }
    });
    
    // 创建多个并发请求
    let mut requests = Vec::new();
    
    for i in 0..5 {
        let request = Request::builder()
            .method(Method::GET)
            .uri(format!("https://httpbin.org/delay/{}", i))
            .body(())?;
        
        let (response, mut send_stream) = client.send_request(request, false)?;
        send_stream.send_data(bytes::Bytes::new(), true)?;
        
        requests.push(tokio::spawn(async move {
            match response.await {
                Ok(resp) => {
                    println!("请求 {} 完成: {}", i, resp.status());
                    // 处理响应体
                    let mut body = resp.into_body();
                    while let Some(chunk) = body.data().await {
                        if let Ok(bytes) = chunk {
                            println!("请求 {} 数据: {}", i, String::from_utf8_lossy(&bytes));
                        }
                    }
                }
                Err(e) => println!("请求 {} 失败: {}", i, e),
            }
        }));
    }
    
    // 等待所有请求完成
    join_all(requests).await;
    
    Ok(())
}
```

### 3. POST 请求与数据发送

```rust
use h2::client;
use http::{Request, Method};
use tokio::net::TcpStream;
use bytes::Bytes;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let tcp = TcpStream::connect("httpbin.org:443").await?;
    let (mut client, h2) = client::handshake(tcp).await?;
    
    tokio::spawn(async move {
        if let Err(e) = h2.await {
            println!("HTTP/2 连接错误: {}", e);
        }
    });
    
    // 创建 POST 请求
    let request = Request::builder()
        .method(Method::POST)
        .uri("https://httpbin.org/post")
        .header("content-type", "application/json")
        .body(())?;
    
    let (response, mut send_stream) = client.send_request(request, false)?;
    
    // 发送 JSON 数据
    let json_data = r#"{"name": "张三", "age": 30, "city": "北京"}"#;
    let data = Bytes::from(json_data);
    
    send_stream.send_data(data, true)?;
    
    // 处理响应
    let response = response.await?;
    println!("POST 响应状态: {}", response.status());
    
    let mut body = response.into_body();
    while let Some(chunk) = body.data().await {
        match chunk {
            Ok(bytes) => println!("响应数据: {}", String::from_utf8_lossy(&bytes)),
            Err(e) => println!("读取错误: {}", e),
        }
    }
    
    Ok(())
}
```

## 服务器使用

### 1. 基本服务器

```rust
use h2::server;
use http::{Request, Response, StatusCode};
use tokio::net::{TcpListener, TcpStream};
use bytes::Bytes;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("HTTP/2 服务器启动在 127.0.0.1:8080");
    
    loop {
        let (socket, _) = listener.accept().await?;
        tokio::spawn(async move {
            if let Err(e) = handle_connection(socket).await {
                println!("连接处理错误: {}", e);
            }
        });
    }
}

async fn handle_connection(socket: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let mut connection = server::handshake(socket).await?;
    
    while let Some(request) = connection.accept().await {
        let (request, mut respond) = request?;
        
        tokio::spawn(async move {
            if let Err(e) = handle_request(request, &mut respond).await {
                println!("请求处理错误: {}", e);
            }
        });
    }
    
    Ok(())
}

async fn handle_request(
    request: Request<h2::RecvStream>,
    respond: &mut h2::server::SendResponse<bytes::Bytes>,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("收到请求: {} {}", request.method(), request.uri());
    
    // 读取请求体
    let mut request_body = request.into_body();
    let mut body_data = Vec::new();
    
    while let Some(chunk) = request_body.data().await {
        match chunk {
            Ok(bytes) => body_data.extend_from_slice(&bytes),
            Err(e) => {
                println!("读取请求体错误: {}", e);
                break;
            }
        }
    }
    
    // 创建响应
    let response_body = format!(
        "Hello from HTTP/2 server!\n请求体大小: {} bytes\n时间: {}",
        body_data.len(),
        chrono::Utc::now().to_rfc3339()
    );
    
    let response = Response::builder()
        .status(StatusCode::OK)
        .header("content-type", "text/plain; charset=utf-8")
        .body(())?;
    
    let mut send_stream = respond.send_response(response, false)?;
    send_stream.send_data(Bytes::from(response_body), true)?;
    
    Ok(())
}
```

### 2. 路由处理

```rust
use h2::server;
use http::{Request, Response, StatusCode, Method};
use tokio::net::{TcpListener, TcpStream};
use bytes::Bytes;
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("HTTP/2 服务器启动在 127.0.0.1:8080");
    
    loop {
        let (socket, _) = listener.accept().await?;
        tokio::spawn(async move {
            if let Err(e) = handle_connection(socket).await {
                println!("连接处理错误: {}", e);
            }
        });
    }
}

async fn handle_connection(socket: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let mut connection = server::handshake(socket).await?;
    
    while let Some(request) = connection.accept().await {
        let (request, mut respond) = request?;
        
        tokio::spawn(async move {
            if let Err(e) = route_request(request, &mut respond).await {
                println!("路由处理错误: {}", e);
            }
        });
    }
    
    Ok(())
}

async fn route_request(
    request: Request<h2::RecvStream>,
    respond: &mut h2::server::SendResponse<bytes::Bytes>,
) -> Result<(), Box<dyn std::error::Error>> {
    let method = request.method().clone();
    let uri = request.uri().clone();
    
    println!("处理请求: {} {}", method, uri);
    
    let response = match (method, uri.path()) {
        (Method::GET, "/") => handle_home().await,
        (Method::GET, "/api/users") => handle_get_users().await,
        (Method::POST, "/api/users") => handle_create_user(request).await,
        (Method::GET, path) if path.starts_with("/api/users/") => {
            let id = path.strip_prefix("/api/users/").unwrap_or("");
            handle_get_user(id).await
        }
        _ => handle_not_found().await,
    };
    
    let mut send_stream = respond.send_response(response, false)?;
    send_stream.send_data(Bytes::from(""), true)?;
    
    Ok(())
}

async fn handle_home() -> Response<()> {
    let body = r#"
    <!DOCTYPE html>
    <html>
    <head><title>HTTP/2 服务器</title></head>
    <body>
        <h1>欢迎使用 HTTP/2 服务器</h1>
        <p>这是一个基于 Rust H2 库的示例服务器</p>
        <ul>
            <li><a href="/api/users">获取用户列表</a></li>
        </ul>
    </body>
    </html>
    "#;
    
    Response::builder()
        .status(StatusCode::OK)
        .header("content-type", "text/html; charset=utf-8")
        .body(())
        .unwrap()
}

async fn handle_get_users() -> Response<()> {
    let users = serde_json::json!([
        {"id": 1, "name": "张三", "email": "zhangsan@example.com"},
        {"id": 2, "name": "李四", "email": "lisi@example.com"},
        {"id": 3, "name": "王五", "email": "wangwu@example.com"}
    ]);
    
    Response::builder()
        .status(StatusCode::OK)
        .header("content-type", "application/json; charset=utf-8")
        .body(())
        .unwrap()
}

async fn handle_get_user(id: &str) -> Response<()> {
    let user = serde_json::json!({
        "id": id,
        "name": format!("用户{}", id),
        "email": format!("user{}@example.com", id)
    });
    
    Response::builder()
        .status(StatusCode::OK)
        .header("content-type", "application/json; charset=utf-8")
        .body(())
        .unwrap()
}

async fn handle_create_user(request: Request<h2::RecvStream>) -> Response<()> {
    // 这里应该读取请求体并创建用户
    let new_user = serde_json::json!({
        "id": 4,
        "name": "新用户",
        "email": "newuser@example.com",
        "created_at": chrono::Utc::now().to_rfc3339()
    });
    
    Response::builder()
        .status(StatusCode::CREATED)
        .header("content-type", "application/json; charset=utf-8")
        .body(())
        .unwrap()
}

async fn handle_not_found() -> Response<()> {
    Response::builder()
        .status(StatusCode::NOT_FOUND)
        .header("content-type", "text/plain; charset=utf-8")
        .body(())
        .unwrap()
}
```

## 高级特性

### 1. 服务器推送（Server Push）

```rust
use h2::server;
use http::{Request, Response, StatusCode};
use tokio::net::{TcpListener, TcpStream};
use bytes::Bytes;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("HTTP/2 服务器启动在 127.0.0.1:8080（支持服务器推送）");
    
    loop {
        let (socket, _) = listener.accept().await?;
        tokio::spawn(async move {
            if let Err(e) = handle_connection_with_push(socket).await {
                println!("连接处理错误: {}", e);
            }
        });
    }
}

async fn handle_connection_with_push(socket: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let mut connection = server::handshake(socket).await?;
    
    while let Some(request) = connection.accept().await {
        let (request, mut respond) = request?;
        
        tokio::spawn(async move {
            if let Err(e) = handle_request_with_push(request, &mut respond).await {
                println!("请求处理错误: {}", e);
            }
        });
    }
    
    Ok(())
}

async fn handle_request_with_push(
    request: Request<h2::RecvStream>,
    respond: &mut h2::server::SendResponse<bytes::Bytes>,
) -> Result<(), Box<dyn std::error::Error>> {
    let uri = request.uri().clone();
    
    if uri.path() == "/" {
        // 推送 CSS 文件
        let css_request = Request::builder()
            .method("GET")
            .uri("/style.css")
            .body(())?;
        
        if let Ok(mut push_stream) = respond.push_request(css_request) {
            let css_response = Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "text/css")
                .body(())?;
            
            let mut css_send_stream = push_stream.send_response(css_response, false)?;
            let css_content = "body { font-family: Arial, sans-serif; background-color: #f0f0f0; }";
            css_send_stream.send_data(Bytes::from(css_content), true)?;
        }
        
        // 推送 JavaScript 文件
        let js_request = Request::builder()
            .method("GET")
            .uri("/script.js")
            .body(())?;
        
        if let Ok(mut push_stream) = respond.push_request(js_request) {
            let js_response = Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/javascript")
                .body(())?;
            
            let mut js_send_stream = push_stream.send_response(js_response, false)?;
            let js_content = "console.log('Hello from pushed JavaScript!');";
            js_send_stream.send_data(Bytes::from(js_content), true)?;
        }
    }
    
    // 发送主响应
    let html_content = r#"
    <!DOCTYPE html>
    <html>
    <head>
        <title>HTTP/2 服务器推送演示</title>
        <link rel="stylesheet" href="/style.css">
    </head>
    <body>
        <h1>HTTP/2 服务器推送演示</h1>
        <p>CSS 和 JavaScript 文件已通过服务器推送提前发送</p>
        <script src="/script.js"></script>
    </body>
    </html>
    "#;
    
    let response = Response::builder()
        .status(StatusCode::OK)
        .header("content-type", "text/html; charset=utf-8")
        .body(())?;
    
    let mut send_stream = respond.send_response(response, false)?;
    send_stream.send_data(Bytes::from(html_content), true)?;
    
    Ok(())
}
```

### 2. 流控制和背压处理

```rust
use h2::server;
use http::{Request, Response, StatusCode};
use tokio::net::{TcpListener, TcpStream};
use bytes::Bytes;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("HTTP/2 服务器启动在 127.0.0.1:8080（流控制演示）");
    
    loop {
        let (socket, _) = listener.accept().await?;
        tokio::spawn(async move {
            if let Err(e) = handle_connection_with_flow_control(socket).await {
                println!("连接处理错误: {}", e);
            }
        });
    }
}

async fn handle_connection_with_flow_control(socket: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let mut connection = server::handshake(socket).await?;
    
    while let Some(request) = connection.accept().await {
        let (request, mut respond) = request?;
        
        tokio::spawn(async move {
            if let Err(e) = handle_streaming_request(request, &mut respond).await {
                println!("流处理错误: {}", e);
            }
        });
    }
    
    Ok(())
}

async fn handle_streaming_request(
    request: Request<h2::RecvStream>,
    respond: &mut h2::server::SendResponse<bytes::Bytes>,
) -> Result<(), Box<dyn std::error::Error>> {
    let uri = request.uri().clone();
    
    match uri.path() {
        "/stream" => {
            // 流式响应
            let response = Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "text/plain; charset=utf-8")
                .header("cache-control", "no-cache")
                .body(())?;
            
            let mut send_stream = respond.send_response(response, false)?;
            
            // 发送分块数据
            for i in 0..10 {
                let chunk = format!("数据块 {}\n", i + 1);
                
                // 检查发送缓冲区容量
                send_stream.reserve_capacity(chunk.len())?;
                
                // 发送数据块
                send_stream.send_data(Bytes::from(chunk), false)?;
                
                // 模拟处理延迟
                sleep(Duration::from_millis(500)).await;
            }
            
            // 结束流
            send_stream.send_data(Bytes::from("流结束\n"), true)?;
        }
        "/large" => {
            // 大文件传输
            let response = Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/octet-stream")
                .header("content-length", "1048576") // 1MB
                .body(())?;
            
            let mut send_stream = respond.send_response(response, false)?;
            
            // 分块发送大文件
            let chunk_size = 8192; // 8KB chunks
            let total_size = 1024 * 1024; // 1MB
            
            for i in 0..(total_size / chunk_size) {
                let chunk = vec![0u8; chunk_size];
                
                // 等待发送缓冲区有足够空间
                send_stream.reserve_capacity(chunk_size)?;
                
                let is_last = i == (total_size / chunk_size) - 1;
                send_stream.send_data(Bytes::from(chunk), is_last)?;
                
                // 给其他任务让出控制权
                tokio::task::yield_now().await;
            }
        }
        _ => {
            // 默认响应
            let response = Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "text/plain; charset=utf-8")
                .body(())?;
            
            let mut send_stream = respond.send_response(response, false)?;
            send_stream.send_data(Bytes::from("Hello from HTTP/2 server!"), true)?;
        }
    }
    
    Ok(())
}
```

### 3. 错误处理和重试机制

```rust
use h2::client;
use http::{Request, Method, StatusCode};
use tokio::net::TcpStream;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = HttpClient::new();
    
    // 演示重试机制
    match client.request_with_retry("https://httpbin.org/status/500", 3).await {
        Ok(response) => println!("请求成功: {}", response.status()),
        Err(e) => println!("请求失败: {}", e),
    }
    
    Ok(())
}

struct HttpClient {
    max_retries: usize,
    retry_delay: Duration,
}

impl HttpClient {
    fn new() -> Self {
        Self {
            max_retries: 3,
            retry_delay: Duration::from_secs(1),
        }
    }
    
    async fn request_with_retry(
        &self,
        url: &str,
        max_retries: usize,
    ) -> Result<http::Response<()>, Box<dyn std::error::Error>> {
        let mut attempts = 0;
        
        loop {
            attempts += 1;
            
            match self.make_request(url).await {
                Ok(response) => {
                    if response.status().is_success() {
                        return Ok(response);
                    } else if response.status().is_server_error() && attempts <= max_retries {
                        println!("服务器错误 {}，第 {} 次重试", response.status(), attempts);
                        tokio::time::sleep(self.retry_delay * attempts as u32).await;
                        continue;
                    } else {
                        return Err(format!("请求失败: {}", response.status()).into());
                    }
                }
                Err(e) => {
                    if attempts <= max_retries {
                        println!("连接错误，第 {} 次重试: {}", attempts, e);
                        tokio::time::sleep(self.retry_delay * attempts as u32).await;
                        continue;
                    } else {
                        return Err(e);
                    }
                }
            }
        }
    }
    
    async fn make_request(&self, url: &str) -> Result<http::Response<()>, Box<dyn std::error::Error>> {
        // 解析 URL
        let uri: http::Uri = url.parse()?;
        let host = uri.host().ok_or("无效的主机")?;
        let port = uri.port_u16().unwrap_or(if uri.scheme_str() == Some("https") { 443 } else { 80 });
        
        // 建立连接
        let tcp = TcpStream::connect((host, port)).await?;
        let (mut client, h2) = client::handshake(tcp).await?;
        
        // 启动连接处理
        tokio::spawn(async move {
            if let Err(e) = h2.await {
                println!("HTTP/2 连接错误: {}", e);
            }
        });
        
        // 创建请求
        let request = Request::builder()
            .method(Method::GET)
            .uri(uri)
            .body(())?;
        
        // 发送请求
        let (response, mut send_stream) = client.send_request(request, false)?;
        send_stream.send_data(bytes::Bytes::new(), true)?;
        
        // 等待响应
        let response = response.await?;
        
        // 读取响应体（这里简化处理）
        let mut body = response.into_body();
        while let Some(chunk) = body.data().await {
            match chunk {
                Ok(_) => {}, // 处理数据
                Err(e) => println!("读取响应体错误: {}", e),
            }
        }
        
        // 返回响应头信息
        Ok(http::Response::builder()
            .status(StatusCode::OK)
            .body(())
            .unwrap())
    }
}
```

## 性能优化

### 1. 连接池

```rust
use h2::client;
use tokio::net::TcpStream;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct ConnectionPool {
    connections: Arc<Mutex<HashMap<String, h2::client::SendRequest<bytes::Bytes>>>>,
    max_connections: usize,
}

impl ConnectionPool {
    pub fn new(max_connections: usize) -> Self {
        Self {
            connections: Arc::new(Mutex::new(HashMap::new())),
            max_connections,
        }
    }
    
    pub async fn get_connection(&self, host: &str, port: u16) -> Result<h2::client::SendRequest<bytes::Bytes>, Box<dyn std::error::Error>> {
        let key = format!("{}:{}", host, port);
        
        {
            let mut connections = self.connections.lock().await;
            if let Some(client) = connections.get_mut(&key) {
                if client.ready().await.is_ok() {
                    return Ok(client.clone());
                } else {
                    // 连接已关闭，移除
                    connections.remove(&key);
                }
            }
        }
        
        // 创建新连接
        let tcp = TcpStream::connect((host, port)).await?;
        let (mut client, h2) = client::handshake(tcp).await?;
        
        // 启动连接处理
        tokio::spawn(async move {
            if let Err(e) = h2.await {
                println!("HTTP/2 连接错误: {}", e);
            }
        });
        
        let send_request = client.clone();
        
        // 存储连接
        {
            let mut connections = self.connections.lock().await;
            if connections.len() < self.max_connections {
                connections.insert(key, client);
            }
        }
        
        Ok(send_request)
    }
}

// 使用示例
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let pool = ConnectionPool::new(10);
    
    // 并发请求
    let mut handles = Vec::new();
    
    for i in 0..20 {
        let pool = pool.clone();
        let handle = tokio::spawn(async move {
            let client = pool.get_connection("httpbin.org", 443).await.unwrap();
            
            let request = http::Request::builder()
                .method(http::Method::GET)
                .uri(format!("https://httpbin.org/delay/{}", i % 3))
                .body(())
                .unwrap();
            
            let (response, mut send_stream) = client.send_request(request, false).unwrap();
            send_stream.send_data(bytes::Bytes::new(), true).unwrap();
            
            let response = response.await.unwrap();
            println!("请求 {} 完成: {}", i, response.status());
        });
        
        handles.push(handle);
    }
    
    // 等待所有请求完成
    for handle in handles {
        handle.await?;
    }
    
    Ok(())
}
```

### 2. 缓冲区优化

```rust
use h2::server;
use http::{Request, Response, StatusCode};
use tokio::net::{TcpListener, TcpStream};
use bytes::{Bytes, BytesMut};
use std::io::Write;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("优化的 HTTP/2 服务器启动在 127.0.0.1:8080");
    
    loop {
        let (socket, _) = listener.accept().await?;
        tokio::spawn(async move {
            if let Err(e) = handle_optimized_connection(socket).await {
                println!("连接处理错误: {}", e);
            }
        });
    }
}

async fn handle_optimized_connection(socket: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let mut connection = server::handshake(socket).await?;
    
    while let Some(request) = connection.accept().await {
        let (request, mut respond) = request?;
        
        tokio::spawn(async move {
            if let Err(e) = handle_optimized_request(request, &mut respond).await {
                println!("请求处理错误: {}", e);
            }
        });
    }
    
    Ok(())
}

async fn handle_optimized_request(
    request: Request<h2::RecvStream>,
    respond: &mut h2::server::SendResponse<bytes::Bytes>,
) -> Result<(), Box<dyn std::error::Error>> {
    let uri = request.uri().clone();
    
    match uri.path() {
        "/optimized" => {
            // 使用预分配的缓冲区
            let mut buffer = BytesMut::with_capacity(1024);
            
            // 构建响应数据
            write!(buffer, "HTTP/2 优化响应\n")?;
            write!(buffer, "请求URI: {}\n", uri)?;
            write!(buffer, "时间戳: {}\n", chrono::Utc::now().to_rfc3339())?;
            
            // 添加一些数据
            for i in 0..100 {
                write!(buffer, "数据行 {}: {}\n", i, "x".repeat(50))?;
            }
            
            let response = Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "text/plain; charset=utf-8")
                .header("content-length", buffer.len().to_string())
                .body(())?;
            
            let mut send_stream = respond.send_response(response, false)?;
            
            // 分块发送以优化内存使用
            let chunk_size = 4096;
            let total_len = buffer.len();
            
            for start in (0..total_len).step_by(chunk_size) {
                let end = std::cmp::min(start + chunk_size, total_len);
                let chunk = buffer.slice(start..end);
                
                let is_last = end == total_len;
                send_stream.send_data(chunk.freeze(), is_last)?;
            }
        }
        _ => {
            let response = Response::builder()
                .status(StatusCode::NOT_FOUND)
                .header("content-type", "text/plain; charset=utf-8")
                .body(())?;
            
            let mut send_stream = respond.send_response(response, false)?;
            send_stream.send_data(Bytes::from("404 Not Found"), true)?;
        }
    }
    
    Ok(())
}
```

## 监控和调试

### 1. 连接状态监控

```rust
use h2::client;
use tokio::net::TcpStream;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use tokio::time::{interval, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let monitor = Arc::new(ConnectionMonitor::new());
    
    // 启动监控任务
    let monitor_clone = monitor.clone();
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(5));
        loop {
            interval.tick().await;
            monitor_clone.report_stats();
        }
    });
    
    // 模拟多个连接
    let mut handles = Vec::new();
    
    for i in 0..10 {
        let monitor = monitor.clone();
        let handle = tokio::spawn(async move {
            monitor.increment_connections();
            
            match make_monitored_request(i).await {
                Ok(_) => {
                    monitor.increment_successful_requests();
                    println!("请求 {} 成功", i);
                }
                Err(e) => {
                    monitor.increment_failed_requests();
                    println!("请求 {} 失败: {}", i, e);
                }
            }
            
            monitor.decrement_connections();
        });
        
        handles.push(handle);
    }
    
    // 等待所有请求完成
    for handle in handles {
        handle.await?;
    }
    
    // 等待最后一次统计报告
    tokio::time::sleep(Duration::from_secs(6)).await;
    
    Ok(())
}

struct ConnectionMonitor {
    active_connections: AtomicUsize,
    total_requests: AtomicUsize,
    successful_requests: AtomicUsize,
    failed_requests: AtomicUsize,
}

impl ConnectionMonitor {
    fn new() -> Self {
        Self {
            active_connections: AtomicUsize::new(0),
            total_requests: AtomicUsize::new(0),
            successful_requests: AtomicUsize::new(0),
            failed_requests: AtomicUsize::new(0),
        }
    }
    
    fn increment_connections(&self) {
        self.active_connections.fetch_add(1, Ordering::SeqCst);
    }
    
    fn decrement_connections(&self) {
        self.active_connections.fetch_sub(1, Ordering::SeqCst);
    }
    
    fn increment_successful_requests(&self) {
        self.total_requests.fetch_add(1, Ordering::SeqCst);
        self.successful_requests.fetch_add(1, Ordering::SeqCst);
    }
    
    fn increment_failed_requests(&self) {
        self.total_requests.fetch_add(1, Ordering::SeqCst);
        self.failed_requests.fetch_add(1, Ordering::SeqCst);
    }
    
    fn report_stats(&self) {
        let active = self.active_connections.load(Ordering::SeqCst);
        let total = self.total_requests.load(Ordering::SeqCst);
        let successful = self.successful_requests.load(Ordering::SeqCst);
        let failed = self.failed_requests.load(Ordering::SeqCst);
        
        println!("=== 连接统计 ===");
        println!("活跃连接: {}", active);
        println!("总请求数: {}", total);
        println!("成功请求: {}", successful);
        println!("失败请求: {}", failed);
        
        if total > 0 {
            let success_rate = (successful as f64 / total as f64) * 100.0;
            println!("成功率: {:.2}%", success_rate);
        }
        
        println!("==================");
    }
}

async fn make_monitored_request(id: usize) -> Result<(), Box<dyn std::error::Error>> {
    let tcp = TcpStream::connect("httpbin.org:443").await?;
    let (mut client, h2) = client::handshake(tcp).await?;
    
    tokio::spawn(async move {
        if let Err(e) = h2.await {
            println!("HTTP/2 连接错误: {}", e);
        }
    });
    
    let request = http::Request::builder()
        .method(http::Method::GET)
        .uri(format!("https://httpbin.org/delay/{}", id % 3))
        .body(())?;
    
    let (response, mut send_stream) = client.send_request(request, false)?;
    send_stream.send_data(bytes::Bytes::new(), true)?;
    
    let response = response.await?;
    
    // 读取响应体
    let mut body = response.into_body();
    while let Some(chunk) = body.data().await {
        match chunk {
            Ok(_) => {}, // 处理数据
            Err(e) => println!("读取响应体错误: {}", e),
        }
    }
    
    Ok(())
}
```

### 2. 性能基准测试

```rust
use h2::client;
use tokio::net::TcpStream;
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("HTTP/2 性能基准测试");
    
    // 并发测试
    benchmark_concurrent_requests(10).await?;
    benchmark_concurrent_requests(50).await?;
    benchmark_concurrent_requests(100).await?;
    
    // 吞吐量测试
    benchmark_throughput(Duration::from_secs(10)).await?;
    
    Ok(())
}

async fn benchmark_concurrent_requests(concurrency: usize) -> Result<(), Box<dyn std::error::Error>> {
    println!("\n=== 并发测试 (并发数: {}) ===", concurrency);
    
    let start_time = Instant::now();
    let mut handles = Vec::new();
    
    for i in 0..concurrency {
        let handle = tokio::spawn(async move {
            let request_start = Instant::now();
            
            match make_test_request(i).await {
                Ok(_) => {
                    let duration = request_start.elapsed();
                    Some(duration)
                }
                Err(e) => {
                    println!("请求 {} 失败: {}", i, e);
                    None
                }
            }
        });
        
        handles.push(handle);
    }
    
    // 收集结果
    let mut durations = Vec::new();
    let mut successful = 0;
    let mut failed = 0;
    
    for handle in handles {
        match handle.await? {
            Some(duration) => {
                durations.push(duration);
                successful += 1;
            }
            None => failed += 1,
        }
    }
    
    let total_time = start_time.elapsed();
    
    // 计算统计数据
    if !durations.is_empty() {
        durations.sort();
        let avg_duration = durations.iter().sum::<Duration>() / durations.len() as u32;
        let median_duration = durations[durations.len() / 2];
        let min_duration = durations[0];
        let max_duration = durations[durations.len() - 1];
        
        println!("总耗时: {:?}", total_time);
        println!("成功请求: {}", successful);
        println!("失败请求: {}", failed);
        println!("平均响应时间: {:?}", avg_duration);
        println!("中位数响应时间: {:?}", median_duration);
        println!("最小响应时间: {:?}", min_duration);
        println!("最大响应时间: {:?}", max_duration);
        println!("RPS: {:.2}", successful as f64 / total_time.as_secs_f64());
    }
    
    Ok(())
}

async fn benchmark_throughput(duration: Duration) -> Result<(), Box<dyn std::error::Error>> {
    println!("\n=== 吞吐量测试 (持续时间: {:?}) ===", duration);
    
    let start_time = Instant::now();
    let mut request_count = 0;
    let mut success_count = 0;
    
    while start_time.elapsed() < duration {
        let batch_size = 10;
        let mut batch_handles = Vec::new();
        
        for i in 0..batch_size {
            let handle = tokio::spawn(async move {
                make_test_request(i).await.is_ok()
            });
            batch_handles.push(handle);
        }
        
        // 等待批次完成
        for handle in batch_handles {
            request_count += 1;
            if handle.await.unwrap_or(false) {
                success_count += 1;
            }
        }
        
        // 稍微等待以避免过度负载
        sleep(Duration::from_millis(10)).await;
    }
    
    let total_time = start_time.elapsed();
    
    println!("总请求数: {}", request_count);
    println!("成功请求数: {}", success_count);
    println!("失败请求数: {}", request_count - success_count);
    println!("平均 RPS: {:.2}", request_count as f64 / total_time.as_secs_f64());
    println!("成功率: {:.2}%", (success_count as f64 / request_count as f64) * 100.0);
    
    Ok(())
}

async fn make_test_request(id: usize) -> Result<(), Box<dyn std::error::Error>> {
    let tcp = TcpStream::connect("httpbin.org:443").await?;
    let (mut client, h2) = client::handshake(tcp).await?;
    
    tokio::spawn(async move {
        if let Err(e) = h2.await {
            // 连接错误处理
        }
    });
    
    let request = http::Request::builder()
        .method(http::Method::GET)
        .uri("https://httpbin.org/get")
        .body(())?;
    
    let (response, mut send_stream) = client.send_request(request, false)?;
    send_stream.send_data(bytes::Bytes::new(), true)?;
    
    let response = response.await?;
    
    // 快速读取响应体
    let mut body = response.into_body();
    while let Some(chunk) = body.data().await {
        match chunk {
            Ok(_) => {}, // 处理数据
            Err(_) => break,
        }
    }
    
    Ok(())
}
```

## 最佳实践

### 1. 生产环境配置

```rust
use h2::server;
use tokio::net::TcpListener;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 生产环境配置
    let server_config = ProductionServerConfig {
        bind_address: "0.0.0.0:8080".to_string(),
        max_concurrent_streams: 1000,
        initial_window_size: 65536,
        max_frame_size: 16384,
        keep_alive_interval: Duration::from_secs(30),
        keep_alive_timeout: Duration::from_secs(5),
    };
    
    start_production_server(server_config).await
}

struct ProductionServerConfig {
    bind_address: String,
    max_concurrent_streams: u32,
    initial_window_size: u32,
    max_frame_size: u32,
    keep_alive_interval: Duration,
    keep_alive_timeout: Duration,
}

async fn start_production_server(config: ProductionServerConfig) -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind(&config.bind_address).await?;
    println!("生产环境 HTTP/2 服务器启动在 {}", config.bind_address);
    
    loop {
        let (socket, peer_addr) = listener.accept().await?;
        let config = config.clone();
        
        tokio::spawn(async move {
            println!("新连接来自: {}", peer_addr);
            
            // 设置 TCP 选项
            let _ = socket.set_nodelay(true);
            
            if let Err(e) = handle_production_connection(socket, config).await {
                println!("连接处理错误 {}: {}", peer_addr, e);
            }
        });
    }
}

async fn handle_production_connection(
    socket: tokio::net::TcpStream,
    config: ProductionServerConfig,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut connection = server::handshake(socket).await?;
    
    // 设置连接参数
    connection.max_concurrent_streams(config.max_concurrent_streams);
    connection.initial_window_size(config.initial_window_size);
    connection.max_frame_size(config.max_frame_size);
    
    while let Some(request) = connection.accept().await {
        let (request, mut respond) = request?;
        
        tokio::spawn(async move {
            if let Err(e) = handle_production_request(request, &mut respond).await {
                println!("请求处理错误: {}", e);
            }
        });
    }
    
    Ok(())
}

async fn handle_production_request(
    request: http::Request<h2::RecvStream>,
    respond: &mut h2::server::SendResponse<bytes::Bytes>,
) -> Result<(), Box<dyn std::error::Error>> {
    // 生产环境请求处理逻辑
    let response = http::Response::builder()
        .status(http::StatusCode::OK)
        .header("content-type", "application/json")
        .header("server", "h2-rust-server/1.0")
        .body(())?;
    
    let mut send_stream = respond.send_response(response, false)?;
    
    let response_data = serde_json::json!({
        "message": "Hello from production HTTP/2 server",
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "version": "1.0.0"
    });
    
    send_stream.send_data(bytes::Bytes::from(response_data.to_string()), true)?;
    
    Ok(())
}
```

### 2. 安全配置

```rust
use h2::server;
use tokio::net::TcpListener;
use tokio_rustls::{TlsAcceptor, rustls};
use std::sync::Arc;
use std::fs;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 设置 TLS
    let tls_config = setup_tls_config()?;
    let acceptor = TlsAcceptor::from(tls_config);
    
    let listener = TcpListener::bind("0.0.0.0:8443").await?;
    println!("安全 HTTP/2 服务器启动在 0.0.0.0:8443");
    
    loop {
        let (socket, peer_addr) = listener.accept().await?;
        let acceptor = acceptor.clone();
        
        tokio::spawn(async move {
            match acceptor.accept(socket).await {
                Ok(tls_stream) => {
                    println!("TLS 连接建立: {}", peer_addr);
                    
                    if let Err(e) = handle_secure_connection(tls_stream).await {
                        println!("安全连接处理错误: {}", e);
                    }
                }
                Err(e) => {
                    println!("TLS 握手失败 {}: {}", peer_addr, e);
                }
            }
        });
    }
}

fn setup_tls_config() -> Result<Arc<rustls::ServerConfig>, Box<dyn std::error::Error>> {
    // 加载证书和私钥
    let cert_file = fs::read("cert.pem")?;
    let key_file = fs::read("key.pem")?;
    
    let cert_chain = rustls_pemfile::certs(&mut cert_file.as_slice())?
        .into_iter()
        .map(rustls::Certificate)
        .collect();
    
    let key = rustls_pemfile::pkcs8_private_keys(&mut key_file.as_slice())?
        .into_iter()
        .map(rustls::PrivateKey)
        .next()
        .ok_or("无法找到私钥")?;
    
    let config = rustls::ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(cert_chain, key)?;
    
    Ok(Arc::new(config))
}

async fn handle_secure_connection(
    tls_stream: tokio_rustls::server::TlsStream<tokio::net::TcpStream>,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut connection = server::handshake(tls_stream).await?;
    
    while let Some(request) = connection.accept().await {
        let (request, mut respond) = request?;
        
        tokio::spawn(async move {
            if let Err(e) = handle_secure_request(request, &mut respond).await {
                println!("安全请求处理错误: {}", e);
            }
        });
    }
    
    Ok(())
}

async fn handle_secure_request(
    request: http::Request<h2::RecvStream>,
    respond: &mut h2::server::SendResponse<bytes::Bytes>,
) -> Result<(), Box<dyn std::error::Error>> {
    // 安全头设置
    let response = http::Response::builder()
        .status(http::StatusCode::OK)
        .header("content-type", "application/json")
        .header("strict-transport-security", "max-age=31536000; includeSubDomains")
        .header("x-content-type-options", "nosniff")
        .header("x-frame-options", "DENY")
        .header("x-xss-protection", "1; mode=block")
        .header("server", "secure-h2-server/1.0")
        .body(())?;
    
    let mut send_stream = respond.send_response(response, false)?;
    
    let response_data = serde_json::json!({
        "message": "Hello from secure HTTP/2 server",
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "secure": true
    });
    
    send_stream.send_data(bytes::Bytes::from(response_data.to_string()), true)?;
    
    Ok(())
}
```

## 总结

H2 是一个功能完整的 HTTP/2 实现，提供了：

1. **完整的 HTTP/2 支持**：多路复用、服务器推送、流控制
2. **高性能**：异步设计，零拷贝优化
3. **灵活的 API**：支持客户端和服务器开发
4. **生产就绪**：错误处理、监控、安全特性
5. **与生态系统集成**：与 Tokio、Hyper 等库良好配合

**使用建议：**
- 在高并发场景中充分利用 HTTP/2 的多路复用特性
- 合理配置连接参数和缓冲区大小
- 实现适当的错误处理和重试机制
- 在生产环境中启用 TLS 和安全头
- 监控连接状态和性能指标

H2 是构建高性能 HTTP/2 应用的优秀选择，特别适合需要低延迟和高吞吐量的场景。